\documentclass[12pt]{scrartcl}

\setlength{\parindent}{0pt}
\setlength{\parskip}{.25cm}

\usepackage{graphicx}

\usepackage{xcolor}

\definecolor{darkred}{rgb}{0.5,0,0}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\usepackage{hyperref}
\hypersetup{
  letterpaper,
  colorlinks,
  linkcolor=red,
  citecolor=darkgreen,
  menucolor=darkred,
  urlcolor=blue,
  pdfpagemode=none,
  pdftitle={CSCE 156 Lab Handout},
  pdfauthor={Christopher M. Bourke},
  pdfsubject={},
  pdfkeywords={}
}

\definecolor{MyDarkBlue}{rgb}{0,0.08,0.45}
\definecolor{MyDarkRed}{rgb}{0.45,0.08,0}
\definecolor{MyDarkGreen}{rgb}{0.08,0.45,0.08}

\definecolor{mintedBackground}{rgb}{0.95,0.95,0.95}
\definecolor{mintedInlineBackground}{rgb}{.90,.90,1}

%\usepackage{newfloat}
\usepackage[newfloat=true]{minted}
\setminted{mathescape,
               linenos,
               autogobble,
               frame=none,
               framesep=2mm,
               framerule=0.4pt,
               %label=foo,
               xleftmargin=2em,
               xrightmargin=0em,
               startinline=true,  %PHP only, allow it to omit the PHP Tags *** with this option, variables using dollar sign in comments are treated as latex math
               numbersep=10pt, %gap between line numbers and start of line
               style=default, %syntax highlighting style, default is "default"
               			    %gallery: http://help.farbox.com/pygments.html
			    	    %list available: pygmentize -L styles
               bgcolor=mintedBackground} %prevents breaking across pages
               
\setmintedinline{bgcolor={mintedBackground}}
\setminted[text]{bgcolor={mintedBackground},linenos=false,autogobble,xleftmargin=1em}
%\setminted[php]{bgcolor=mintedBackgroundPHP} %startinline=True}
\SetupFloatingEnvironment{listing}{name=Code Sample}
\SetupFloatingEnvironment{listing}{listname=List of Code Samples}

\title{CSCE 156 -- Computer Science II}
\subtitle{Lab 6.0 - Polymorphism}
\author{~}
\date{~}

\begin{document}

\maketitle

\section*{Prior to Lab}

\begin{enumerate}
  \item Review this laboratory handout prior to lab.
  \item Read the Oracle tutorial on Sub-type Polymorphism: \\
	\url{http://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html}
  \item Read the Oracle tutorial on Method Overloading in Java: \\
	\url{http://docs.oracle.com/javase/tutorial/java/javaOO/methods.html}
  \item Read the Oracle tutorial on Java Generics: \\
  \url{http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html}
\end{enumerate}

\section*{Lab Objectives \& Topics}
Following the lab, you should be able to:
\begin{itemize}
  \item Understand and be able to use various forms of polymorphism 
  	including sub-type polymorphism, method overloading, and 
	parameterized polymorphism
  \item Understand and be able to use method overloading and generics 
	in Java
\end{itemize}


\section*{Peer Programming Pair-Up}

To encourage collaboration and a team environment, labs will be
structured in a \emph{pair programming} setup.  At the start of
each lab, you will be randomly paired up with another student 
(conflicts such as absences will be dealt with by the lab instructor).
One of you will be designated the \emph{driver} and the other
the \emph{navigator}.  

The navigator will be responsible for reading the instructions and
telling the driver what to do next.  The driver will be in charge of the
keyboard and workstation.  Both driver and navigator are responsible
for suggesting fixes and solutions together.  Neither the navigator
nor the driver is ``in charge.''  Beyond your immediate pairing, you
are encouraged to help and interact and with other pairs in the lab.

Each week you should alternate: if you were a driver last week, 
be a navigator next, etc.  Resolve any issues (you were both drivers
last week) within your pair.  Ask the lab instructor to resolve issues
only when you cannot come to a consensus.  

Because of the peer programming setup of labs, it is absolutely 
essential that you complete any pre-lab activities and familiarize
yourself with the handouts prior to coming to lab.  Failure to do
so will negatively impact your ability to collaborate and work with 
others which may mean that you will not be able to complete the
lab.  

\section*{Getting Started}

Clone the project code for this lab from GitHub in Eclipse using the
URL, \url{https://github.com/cbourke/CSCE156-Lab06-Polymorphism}.
Refer to Lab 01 for instructions on how to clone a project from GitHub.

\section*{Polymorphism}

Polymorphism is the ability for variables, methods, and classes to 
take on different forms (types) at different points in the execution 
of a program.  Polymorphism can take on various forms and allows us 
to write more general code that can be applied to different types 
of variables and classes.

The classical form of polymorphism is subtype polymorphism where you 
can treat a type $T$ as its super type $S$ but the subtype retains 
its methods and behavior.  Typically this is done so that code that 
can be written generally enough to be applied to type $S$ can be applied 
to any subtype of $S$. 

\subsection*{Method Overloading}

One simple type of polymorphism is method (or function) overloading.  
This is where several versions of a method can be defined with the 
same name, possibly different return types, but with different 
parameters.  Parameters may differ either in type or in arity (a 
different number of parameters).

One example can be found in Java's Math class, which contains four 
different absolute value methods but all with the same name, 
\mintinline{java}{abs()}.  Each of the four methods takes a single 
argument, but differ in the type of variable they take: 
\mintinline{java}{double}, \mintinline{java}{float}, \mintinline{java}{int}, 
and \mintinline{java}{long}.  Contrast this with a language such as
C that doesn't support function overloading.  In the C language, there 
are several different absolute value functions all with different 
names.  

Method overloading allows us to define several methods with the same 
name so that when we invoke the method we only need to use one method 
name.  Which method is actually invoked is determined at compile time 
through static dispatch.  Depending on the number and types of parameters 
we provide when we call the method, the compiler is able to determine 
which version of the function was intended.

\subsection*{Parameterized Polymorphism}

Parametric polymorphism is when code is written without a specific 
type and instead can be applied to any type or types.  Typically, 
the arguments that you provide to a method or variable declarations 
within a method have a fixed type (\mintinline{java}{int}, 
\mintinline{java}{double}, \mintinline{java}{String}, etc.).  
However,  often code can be written generically as it doesn't depend 
on any particular property of the types that it is applied to.

As an example, consider a \mintinline{java}{getMax()} method applied 
to a collection of integers, doubles, or Strings which returns the 
maximal value in each of the lists (numerically or lexicographically).  
Without parameterized polymorphism we would need to write 3 different 
methods even though the logic of the code would be the same (save 
perhaps for the way comparisons are made).  As a better alternative, 
we could write one method, which could be applied to any collection 
of a generic type \mintinline{java}{T}.  Here, \mintinline{java}{T} 
serves as a parameterized \emph{type}--you provide the method with 
a collection of objects of type \mintinline{java}{T} and it will 
find the maximum among them and return it. 

Of course, we may need a minimal amount of information about the 
type \mintinline{java}{T}.  In this particular case, we would need 
to know how to compare objects of type \mintinline{java}{T} with 
each other in order to find the maximum.  This introduces the need 
for \emph{bounded} parameterized polymorphism.  In the context of 
the \mintinline{java}{getMax()} method, we would need to know that 
objects of type \mintinline{java}{T} are (in some way) comparable 
to each other and how to compare them.  

Another context in which we would bound a parameterization is when 
we only want objects of a particular type that are also a subclass 
of some other class.  For example, numerical methods such as a sum 
or average method could be made generic, but could be bounded to 
specify that the type must also be a subclass of a \mintinline{java}{Number}.

\section*{Activities}

In the following activities you will explore polymorphism in the Java programming language.  Specifically, you will learn to define, apply 
and use overloaded methods and generic types.  

\subsection*{Method Overloading}

A \emph{moment} is a statistical measure of the ``shape'' of a set 
of points.  That is, it measures how a distribution deviates from a 
point.  Formally, the $k$-th moment of a set of points $x_1, \ldots, x_n$
is defined as follows.

\[ \frac{1}{n} \sum_{i=1}^n (x_i - \alpha)^k \]

Where $\alpha$ is a real number and $k > 0$ is an integer.  This is 
the most general form of the formula with $\alpha$ and $k$ provided as
parameters.  Otherwise, the ``default'' values for each are 0 and 1 
respectively.

You may recognize several special cases of the moment: for 
$\alpha = 0, k = 1$ this is the sample mean; for $\alpha$ being the 
mean, and $k = 2$, this is the definition of variance.  

\begin{enumerate}
  \item Open the \mintinline{java}{MomentStats} class file in 
	the \mintinline{java}{unl.cse.overloading} package.
  \item Define and implement 4 static methods that compute the
    moment.  All of them should 
	take a list of numbers, but they should differ as follows.
	\begin{itemize}
	  \item One that takes only $\alpha$ as a parameter
	  \item One that takes only $k$ as a parameter
	  \item One that takes both $\alpha$ and $k$
	  \item One that takes neither
	\end{itemize}
	In the cases where a parameter is not provided, use the 
	default(s) mentioned above.
  \item In the \mintinline{java}{main()} method, call the methods
  	you wrote with the provided list of \mintinline{java}{double} 
	values and answer the questions in your worksheet.
\end{enumerate}
	
\subsection*{Using Parameterized Classes}

The Java collections framework extensively uses parameterized types 
to define generic data structures that can hold collections of 
similar objects.  You are likely familiar with the \mintinline{java}{List} 
and \mintinline{java}{Set} interfaces already.  These can be 
parameterized to hold a single type of object.

Another useful data structure is a \mintinline{java}{Map<K,V>}, which 
associates a key object (of type \mintinline{java}{K}) to a value 
object (of type \mintinline{java}{V}).  The parameterization ensures 
that only objects of type \mintinline{java}{K} can be used as a key 
and only objects of type \mintinline{java}{V} can be used as values 
in the map.  Key-value pairs can be placed into the map using the 
\mintinline{java}{put()} method and can be retrieved using the 
\mintinline{java}{get()} method.  

In this exercise, you will familiarize yourself with maps by using one 
to compute the multiplicity of a list of integers and subsequently 
to find the mode of the list.  Recall that the multiplicity of a 
number $x$ in a list of integers is the number of times it appears 
in the list.  The mode of a list of numbers is the value (or values) 
that appears the most.

\begin{enumerate}
  \item Open the \mintinline{java}{ModeDemo} class file in the 
	\mintinline{java}{unl.cse.maps} package.
  \item You will find several methods already completed for you.  
	You need to implement the \mintinline{java}{computeMultiplicities()} 
	and \mintinline{java}{findModes()} methods.  Refer to the comments 
	on how to use the \mintinline{java}{Map} data structure.  Note 
	that \mintinline{java}{Map} is an interface.  \mintinline{java}{HashMap} 
	is a useful implementation of this interface.
  \item Execute your program and answer the questions in your worksheet.
\end{enumerate}

\subsection*{Creating Parameterized Classes}

In this activity you will explore how to parameterize classes in 
Java using generics, and observe the consequences of not parameterizing.  
Generics were introduced in Java 5.  Prior to that (and for backwards 
compatibility), Java used \emph{raw types}.  That is, collections 
such as \mintinline{java}{List}s and \mintinline{java}{Set}s could 
hold any type of Java \mintinline{java}{Object}.  The syntax for 
parameterizing a java class is to include a \mintinline{java}{<T>} 
in its declaration:

\begin{minted}{java}
public class Foo <T> {
  ...
}
\end{minted}

Once parameterized, the type \mintinline{java}{T} can now be used 
in the body of the class, which will take on whatever type instances 
of \mintinline{java}{Foo} are instantiated with.  Once a parameterized 
class has been defined, the following syntax can be used to instantiate 
an instance of \mintinline{java}{Foo} parameterized with an integer type:

\mintinline{java}{Foo<Integer> bar = new Foo<Integer>();}

Parameters can be bounded using the \mintinline{java}{extends} keyword.  
For example \mintinline{java}{<T extends Bar>} will match any type 
\mintinline{java}{T}, but \mintinline{java}{T} must be a subclass of 
\mintinline{java}{Bar}.

When you use a variable to represent your type, this is known as a 
\emph{named parameter} and is used when you need to refer to the type 
(such as when you declare a variable, method parameter, or method 
return type that needs to match \mintinline{java}{T}).  However, if 
you don't need to refer to the type, it is better to use the wildcard, 
\mintinline{java}{?} instead of a specific type.  The wildcard 
matches any type and can still be used in conjunction with the 
\mintinline{java}{extends} keyword to specify ``any type that is a 
subtype of \mintinline{java}{Bar}'' (using the syntax 
\mintinline{java}{<? extends Bar>}).

It is also possible to use generics of generics.  For example, the 
following creates an \mintinline{java}{ArrayList} that is 
parameterized to only hold objects of type \mintinline{java}{Foo} 
that have themselves been parameterized with a \mintinline{java}{Double}:

\mintinline{java}{List<Foo<Double>> baz = new ArrayList<Foo<Double>>();}

Several classes have been provided in the project to model 
\mintinline{java}{Undergraduate} students, \mintinline{java}{Graduate} 
students (both of which are subclasses of \mintinline{java}{Student}), 
and \mintinline{java}{Droids} (which are not students).  Also 
included are \mintinline{java}{Course}s, which may have \mintinline{java}{Section}s.  These classes are intended to model an enrollment 
system based on the following rules:
\begin{itemize}
  \item Each \mintinline{java}{Section} should only hold student 
    types and each \mintinline{java}{Section} should only consist 
    of one type of \mintinline{java}{Student} (grads and undergrads 
    should not be able to enroll in the same section)
  \item Each \mintinline{java}{Course} should be able to hold any 
    number of sections, but those sections should conform to the 
    previous rules.
\end{itemize}

Follow the instructions below to parameterize your classes to conform 
to these rules and to understand the implications of not parameterizing 
your classes.

\subsubsection*{1. Parameterizing a class}

\begin{enumerate}
  \item Open the \mintinline{java}{CourseDemo}, \mintinline{java}{Course}, 
    and \mintinline{java}{Section} classes in the unl.cse package.  
    Two instances of each entity (\mintinline{java}{Undergraduate}, 
    \mintinline{java}{Graduate}, \mintinline{java}{Droid}) have been 
    created for you (feel free to modify or add if you wish).
  \item In the \mintinline{java}{CourseDemo} class create a 
    \mintinline{java}{Section} and enroll all 6 instances to this 
    section.
\end{enumerate}
    
\textbf{Problem}: Observe that since the \mintinline{java}{Section} 
class is not parameterized (it uses raw types) we are able to add 
any of these three types into the same section, violating rule 1 
above.

\textbf{Solution}: Parameterize the \mintinline{java}{Section} class 
so that each section can only hold one type of object.  Update the rest 
of the \mintinline{java}{Section} class to use this type as needed.
Observe that in the \mintinline{java}{CourseDemo} the code you wrote 
should now be giving you warnings: the \mintinline{java}{Section} 
class is now parameterized so you should parameterize instances 
when you create them.  An example:

\mintinline{java}{Section<Undergraduate> ugradSection = new Section<Undergraduate>("001");}

Modify your code in the \mintinline{java}{CourseDemo} to create three 
separate sections (one for \mintinline{java}{Undergraduate}, 
\mintinline{java}{Graduate}, and \mintinline{java}{Droids}) and 
add the entities to the appropriate section instead.

\subsubsection*{2. Parameterizing with a Bound}

\textbf{Problem}: The \mintinline{java}{Course} class still allows 
us to add sections consisting of non-student objects  

\textbf{Solution A}: we could parameterize the \mintinline{java}{Course} 
class just like we did with the \mintinline{java}{Section} class 
to only hold \mintinline{java}{Section}s of a particular type.   
Try this solution.

\textbf{New Problem}: You will find that you are not able to add 
sections holding different types.  Explain, in your own words, 
why this is the case on your worksheet.

\textbf{Solution B}: We want the \mintinline{java}{Course} class to 
be able to hold \mintinline{java}{Section}s of any type of student.  
Remove the parameterizations you did in Solution A and instead of 
parameterizing the class, parameterize the \mintinline{java}{courseRoster} 
list so that it can only hold sections containing objects which must 
be a subtype of \mintinline{java}{Student} (hint: use the wildcard).  
Make any additional changes in the \mintinline{java}{Course} class 
as necessary.  If your changes were correct, then adding the section 
of \mintinline{java}{Droid}s should no longer be allowed.

\subsubsection*{3. Parameterizing a class with a bound}

\textbf{Problem}: though we can no longer add a section to a course 
with non-student objects, we are still able to instantiate a section 
with non-student objects 

\textbf{Solution}: parameterize the \mintinline{java}{Section} class 
so that it can only hold one type of object and that type of object 
must be a subtype of \mintinline{java}{Student}.

Present your final solution to a lab instructor and have them sign
your worksheet.

\section*{Advanced Activities (Optional)}

\begin{enumerate}
  \item Modify the code in the \mintinline{java}{ModeDemo} class to 
  	accept lists containing any type of numbers.  Modify the remaining 
	code to work with these modifications.
  \item Modify the moment exercise to make your methods generic as 
    well as overloaded.  In particular, your methods should accept any 
    list of numbers (not just a list of a particular number type, but 
    a list containing any collection of numbers).  To facilitate this, 
    make use of the generic wildcard in Java: 
    
    \mintinline{java}{<? extends java.lang.Number>}
    
  \item Modify how courses are printed out: add support for ordering 
    students in alphabetic order according to last name/first name.  
    Make use of either a \mintinline{java}{Comparator} or a 
    \mintinline{java}{SortedSet}, parameterized appropriately.
\end{enumerate}

\end{document}
